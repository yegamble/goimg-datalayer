name: CI

# CI Pipeline Optimization Notes:
# - Service containers (PostgreSQL, Redis) are duplicated across jobs due to
#   GitHub Actions job isolation - this is a platform limitation, not a configuration issue
# - Common database setup logic (migrations, health checks) is extracted to a
#   composite action (.github/actions/setup-database) to reduce duplication
# - Jobs run in parallel where possible to minimize total CI time

# Trigger on push to main/develop branches and all pull requests
on:
  push:
    branches:
      - main
      - develop
      - 'claude/*'
  pull_request:
    branches:
      - "**"

# Cancel in-progress runs on new commits to the same PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: "1.23.x"  # Use latest patch version of Go 1.23
  GOLANGCI_LINT_VERSION: "v1.61"

jobs:
  # ============================================================================
  # Linting - Code quality and style checks
  # ============================================================================
  lint:
    name: Lint
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Set up Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@971e284b6050e8a5849b72094c50ab08da042db8 # v6.1.1
        with:
          version: ${{ env.GOLANGCI_LINT_VERSION }}
          args: --timeout=5m --config=.golangci.yml
          # Only show new issues on PRs
          only-new-issues: ${{ github.event_name == 'pull_request' }}

      - name: Run go fmt check
        run: |
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "The following files are not formatted:"
            gofmt -s -l .
            exit 1
          fi

      - name: Run go vet
        run: go vet ./...

  # ============================================================================
  # Unit Tests - Fast, isolated tests with race detection
  # ============================================================================
  test-unit:
    name: Unit Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Set up Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod verify

      - name: Run unit tests with race detection
        run: |
          echo "Running unit tests..."
          go test -race -short -coverprofile=coverage-unit.out -covermode=atomic \
            -timeout 10m -parallel=4 -tags='!integration' ./... 2>&1 | tee test-output.txt || TEST_EXIT=$?

          # Check if any tests were run
          if grep -q "no test files" test-output.txt || [ ! -f coverage-unit.out ]; then
            echo "No unit tests found or no coverage generated"
            # Create empty coverage file so downstream jobs don't fail
            echo "mode: atomic" > coverage-unit.out
          fi

          # Exit with original test exit code if tests failed
          exit ${TEST_EXIT:-0}

      - name: Add Unit Test Coverage Summary
        if: always()
        run: |
          echo "## Unit Test Coverage" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f coverage-unit.out ] && [ -s coverage-unit.out ] && [ "$(wc -l < coverage-unit.out)" -gt 1 ]; then
            TOTAL_COVERAGE=$(go tool cover -func=coverage-unit.out | grep total | awk '{print $3}')
            echo "**Total Unit Coverage:** ${TOTAL_COVERAGE}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Top Packages" >> $GITHUB_STEP_SUMMARY
            echo "| Package | Coverage |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|----------|" >> $GITHUB_STEP_SUMMARY
            go tool cover -func=coverage-unit.out | grep -v "total:" | head -20 | \
              awk '{printf "| %s | %s |\n", $1, $3}' >> $GITHUB_STEP_SUMMARY || true
          else
            echo "No unit tests found yet." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload unit test coverage
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4.4.0
        if: always()
        with:
          name: coverage-unit
          path: coverage-unit.out
          retention-days: 7

  # ============================================================================
  # Domain Layer Tests - Core business logic with 90% coverage threshold
  # ============================================================================
  domain-tests:
    name: Domain Layer Tests (90% threshold)
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Set up Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run Domain Tests
        run: |
          echo "Running domain layer tests..."
          # Check if domain tests exist
          if go list ./internal/domain/... 2>/dev/null | grep -q .; then
            go test -race -coverprofile=domain-coverage.out \
              -covermode=atomic -timeout 5m ./internal/domain/... 2>&1 | tee domain-test-output.txt || DOMAIN_TEST_EXIT=$?

            # Check if coverage was generated
            if [ ! -f domain-coverage.out ] || grep -q "no test files" domain-test-output.txt; then
              echo "No domain tests found or no coverage generated (expected during early development)"
              echo "mode: atomic" > domain-coverage.out
              echo "domain_tests_exist=false" >> $GITHUB_ENV
            else
              echo "domain_tests_exist=true" >> $GITHUB_ENV
            fi

            # Exit with test result if tests exist
            exit ${DOMAIN_TEST_EXIT:-0}
          else
            echo "No domain packages found yet (expected during Sprint 1 Week 3-4)"
            echo "mode: atomic" > domain-coverage.out
            echo "domain_tests_exist=false" >> $GITHUB_ENV
          fi

      - name: Check Domain Coverage Threshold
        if: env.domain_tests_exist == 'true'
        run: |
          COVERAGE=$(go tool cover -func=domain-coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          echo "Domain layer coverage: ${COVERAGE}%"

          if (( $(echo "$COVERAGE < 90" | bc -l) )); then
            echo "::error::Domain coverage ${COVERAGE}% below 90% threshold"
            echo "The domain layer requires 90% coverage as it contains core business logic"
            exit 1
          fi
          echo "::notice::Domain coverage ${COVERAGE}% meets 90% threshold ✓"

      - name: Add Coverage Summary
        if: always()
        run: |
          echo "## Domain Layer Coverage" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f domain-coverage.out ] && [ "${{ env.domain_tests_exist }}" == "true" ]; then
            TOTAL_COVERAGE=$(go tool cover -func=domain-coverage.out | grep total | awk '{print $3}')
            echo "**Total Domain Coverage:** ${TOTAL_COVERAGE}" >> $GITHUB_STEP_SUMMARY
            echo "**Required Threshold:** 90%" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Package Breakdown" >> $GITHUB_STEP_SUMMARY
            echo "| Package | Coverage |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|----------|" >> $GITHUB_STEP_SUMMARY
            go tool cover -func=domain-coverage.out | grep -E "internal/domain" | grep -v "total:" | \
              awk '{printf "| %s | %s |\n", $1, $3}' >> $GITHUB_STEP_SUMMARY || true
          else
            echo "No domain tests found yet. This is expected during Sprint 1 Week 3-4." >> $GITHUB_STEP_SUMMARY
            echo "Domain tests will be added as the domain layer is implemented." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload domain test coverage
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4.4.0
        if: always()
        with:
          name: coverage-domain
          path: domain-coverage.out
          retention-days: 7

  # ============================================================================
  # Integration Tests - Database and service integration tests
  # ============================================================================
  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20

    # Service containers for integration tests
    # NOTE: These containers cannot be shared with E2E tests due to GitHub Actions
    # job isolation. Each job requires its own service containers.
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: goimg_test
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: goimg_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgresql://goimg_test:test_password@localhost:5432/goimg_test?sslmode=disable
      REDIS_URL: redis://localhost:6379/0

    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Set up Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod verify

      - name: Setup database and run migrations
        uses: ./.github/actions/setup-database
        with:
          database-url: ${{ env.DATABASE_URL }}

      - name: Run integration tests
        run: |
          # Run integration tests if they exist, otherwise create empty coverage file
          echo "Running integration tests..."
          go test -race -coverprofile=coverage-integration.out -covermode=atomic \
            -timeout 15m -parallel=2 -tags=integration ./... 2>&1 | tee test-output.txt

          # Check if any tests were run
          if grep -q "no test files" test-output.txt || grep -q "no packages to test" test-output.txt; then
            echo "No integration tests found (expected in early development)"
            # Create empty coverage file so downstream jobs don't fail
            echo "mode: atomic" > coverage-integration.out
          elif [ ! -f coverage-integration.out ]; then
            echo "No integration tests with coverage found"
            echo "mode: atomic" > coverage-integration.out
          fi

      - name: Add Integration Test Coverage Summary
        if: always()
        run: |
          echo "## Integration Test Coverage" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f coverage-integration.out ] && [ -s coverage-integration.out ] && [ "$(wc -l < coverage-integration.out)" -gt 1 ]; then
            TOTAL_COVERAGE=$(go tool cover -func=coverage-integration.out | grep total | awk '{print $3}')
            echo "**Total Integration Coverage:** ${TOTAL_COVERAGE}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Tested Packages" >> $GITHUB_STEP_SUMMARY
            echo "| Package | Coverage |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|----------|" >> $GITHUB_STEP_SUMMARY
            go tool cover -func=coverage-integration.out | grep -v "total:" | head -20 | \
              awk '{printf "| %s | %s |\n", $1, $3}' >> $GITHUB_STEP_SUMMARY || true
          else
            echo "No integration tests found yet." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload integration test coverage
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4.4.0
        if: always()
        with:
          name: coverage-integration
          path: coverage-integration.out
          retention-days: 7

  # ============================================================================
  # Coverage Analysis - Enforce minimum coverage thresholds
  # ============================================================================
  coverage:
    name: Coverage Analysis
    runs-on: ubuntu-latest
    needs: [test-unit, test-integration, domain-tests]
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Set up Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download unit test coverage
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: coverage-unit

      - name: Download integration test coverage
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: coverage-integration

      - name: Download domain test coverage
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: coverage-domain

      - name: Merge coverage reports
        run: |
          # Install gocovmerge to combine coverage files
          go install github.com/wadey/gocovmerge@latest
          gocovmerge coverage-unit.out coverage-integration.out coverage-domain.out > coverage-merged.out

      - name: Calculate coverage percentage
        id: coverage
        run: |
          COVERAGE=$(go tool cover -func=coverage-merged.out | grep total | awk '{print $3}' | sed 's/%//')
          echo "Total coverage: ${COVERAGE}%"
          echo "coverage=${COVERAGE}" >> $GITHUB_OUTPUT

          # Check if we have meaningful test coverage (more than 10 statements covered)
          STATEMENTS=$(go tool cover -func=coverage-merged.out | grep total | awk '{print $2}')
          echo "statements_covered=${STATEMENTS}" >> $GITHUB_OUTPUT

      - name: Enforce 80% coverage threshold
        run: |
          COVERAGE=${{ steps.coverage.outputs.coverage }}
          STATEMENTS=${{ steps.coverage.outputs.statements_covered }}
          THRESHOLD=80.0

          # Only enforce strict threshold on main/develop branches
          # On feature branches, report but don't fail (allows iterative development)
          BRANCH="${{ github.ref }}"
          IS_MAIN_OR_DEVELOP=false
          if [[ "$BRANCH" == "refs/heads/main" ]] || [[ "$BRANCH" == "refs/heads/develop" ]]; then
            IS_MAIN_OR_DEVELOP=true
          fi

          echo "Branch: $BRANCH"
          echo "Coverage: ${COVERAGE}%"
          echo "Statements covered: ${STATEMENTS}"
          echo "Threshold: ${THRESHOLD}%"

          if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
            if [ "$IS_MAIN_OR_DEVELOP" = true ]; then
              echo "ERROR: Coverage ${COVERAGE}% is below threshold ${THRESHOLD}%"
              echo "Strict enforcement on main/develop branches"
              exit 1
            else
              echo "WARNING: Coverage ${COVERAGE}% is below threshold ${THRESHOLD}%"
              echo "This is acceptable on feature branches during development"
              echo "Ensure coverage meets threshold before merging to main"
            fi
          else
            echo "SUCCESS: Coverage ${COVERAGE}% meets threshold ${THRESHOLD}%"
          fi

      - name: Generate coverage HTML report
        run: go tool cover -html=coverage-merged.out -o coverage.html

      - name: Upload merged coverage report
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4.4.0
        with:
          name: coverage-report
          path: |
            coverage-merged.out
            coverage.html
          retention-days: 30

      - name: Comment PR with coverage
        if: github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@331f8f5b4215f0445d3c07b4967662a32a2d3e31 # v2.9.0
        with:
          header: coverage
          message: |
            ## Coverage Report

            **Total Coverage:** ${{ steps.coverage.outputs.coverage }}%
            **Statements Covered:** ${{ steps.coverage.outputs.statements_covered }}
            **Threshold:** 80%

            Status: ${{ steps.coverage.outputs.coverage >= 80 && '✅ PASS' || '⚠️ Below threshold (acceptable on feature branches)' }}

            > Note: Coverage threshold is enforced on main/develop branches only. Feature branches can merge with lower coverage during development.

  # ============================================================================
  # OpenAPI Validation - Ensure API spec is valid
  # Only runs if OpenAPI spec exists (added in Sprint 1 Week 2)
  # ============================================================================
  openapi-validation:
    name: OpenAPI Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Check if OpenAPI spec exists
        id: check_openapi
        run: |
          if [ -f "api/openapi/openapi.yaml" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "OpenAPI spec found, will validate"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "OpenAPI spec not found, skipping validation (expected in Sprint 1 Week 2)"
          fi

      - name: Validate OpenAPI spec
        if: steps.check_openapi.outputs.exists == 'true'
        uses: char0n/swagger-editor-validate@d16c61ab5afd355c4f8fafe8d92d438e177e3a2e # v1.3.2
        with:
          definition-file: api/openapi/openapi.yaml

      - name: Check for OpenAPI spec drift
        if: steps.check_openapi.outputs.exists == 'true'
        run: |
          # Verify that generated code matches OpenAPI spec
          # This prevents manual edits to generated files
          if [ -f "Makefile" ]; then
            if grep -q "generate" Makefile; then
              echo "Checking for OpenAPI drift..."
              make generate || echo "No generate target or generation not required"

              # Check if any files were modified
              if ! git diff --quiet; then
                echo "ERROR: Generated code is out of sync with OpenAPI spec"
                echo "Modified files:"
                git diff --name-only
                echo ""
                echo "Run 'make generate' locally and commit the changes"
                exit 1
              fi
              echo "SUCCESS: Generated code is in sync with OpenAPI spec"
            fi
          fi

  # ============================================================================
  # Security Scanning - Basic security checks (detailed in security.yml)
  # ============================================================================
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Set up Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run gosec security scanner
        uses: securego/gosec@26e57d6b340778c2983cd61775bc7e8bb41d002a # v2.21.4
        with:
          args: '-fmt sarif -out gosec-results.sarif ./...'

      - name: Upload gosec results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: gosec-results.sarif

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@6e7b7d1fd3e4fef0c5fa8cce1229c54b2c9bd0d8 # v0.24.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: trivy-results.sarif

  # ============================================================================
  # Build Verification - Ensure the project builds successfully
  # Only runs after tests pass to save CI minutes
  # ============================================================================
  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint, test-unit, test-integration, domain-tests]
    timeout-minutes: 10

    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Set up Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build project
        run: |
          # Build all commands in cmd/ with optimization flags
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
          BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          GIT_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

          # Build flags for size optimization and reproducible builds
          LDFLAGS="-s -w -X main.Version=${VERSION} -X main.BuildTime=${BUILD_TIME} -X main.GitCommit=${GIT_COMMIT}"

          for dir in cmd/*; do
            if [ -d "$dir" ]; then
              echo "Building $dir..."
              go build -v -trimpath -ldflags="${LDFLAGS}" "./$dir"
            fi
          done

      - name: Verify no uncommitted changes
        run: |
          if ! git diff --quiet; then
            echo "ERROR: Build process modified files"
            git diff
            exit 1
          fi

  # ============================================================================
  # E2E Tests - Newman/Postman API testing
  # Runs against a live API server (requires build to pass)
  # ============================================================================
  e2e-tests:
    name: E2E Tests (Newman)
    runs-on: ubuntu-latest
    needs: [build]
    timeout-minutes: 15
    # Only run E2E tests when the API server and Postman collection exist
    if: |
      always() &&
      needs.build.result == 'success'

    # Service containers for E2E tests
    # NOTE: These containers are duplicates of integration test containers due to
    # GitHub Actions job isolation. Each job requires its own service containers.
    # This is a platform limitation and cannot be optimized away.
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: goimg_test
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: goimg_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgresql://goimg_test:test_password@localhost:5432/goimg_test?sslmode=disable
      REDIS_URL: redis://localhost:6379/0

    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Check if E2E tests exist
        id: check_e2e
        run: |
          if [ -f "tests/e2e/postman/goimg-api.postman_collection.json" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Postman collection found, will run E2E tests"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Postman collection not found, skipping E2E tests"
          fi

      - name: Set up Go
        if: steps.check_e2e.outputs.exists == 'true'
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Set up Node.js (for Newman)
        if: steps.check_e2e.outputs.exists == 'true'
        uses: actions/setup-node@60edb5dd545a775178f52524783378180af0d1f8 # v4.0.2
        with:
          node-version: '20'

      - name: Install Newman
        if: steps.check_e2e.outputs.exists == 'true'
        run: npm install -g newman newman-reporter-htmlextra

      - name: Setup database and run migrations
        if: steps.check_e2e.outputs.exists == 'true'
        uses: ./.github/actions/setup-database
        with:
          database-url: ${{ env.DATABASE_URL }}

      - name: Build API server
        if: steps.check_e2e.outputs.exists == 'true'
        run: |
          if [ -d "cmd/api" ] || [ -d "cmd/server" ]; then
            go build -o api-server ./cmd/api 2>/dev/null || go build -o api-server ./cmd/server 2>/dev/null || echo "No API server found"
          else
            echo "API server not yet implemented, skipping E2E tests"
            echo "skip_e2e=true" >> $GITHUB_ENV
          fi

      - name: Start API server
        if: steps.check_e2e.outputs.exists == 'true' && env.skip_e2e != 'true'
        run: |
          if [ -f "api-server" ]; then
            ./api-server &
            echo "API_PID=$!" >> $GITHUB_ENV
            # Wait for server to be ready
            for i in {1..30}; do
              curl -s http://localhost:8080/health/live && break
              echo "Waiting for API server..."
              sleep 1
            done
          else
            echo "API server binary not found"
            echo "skip_e2e=true" >> $GITHUB_ENV
          fi

      - name: Create test fixtures
        if: steps.check_e2e.outputs.exists == 'true' && env.skip_e2e != 'true'
        run: |
          mkdir -p tests/e2e/fixtures
          # Create a minimal valid JPEG for upload tests
          echo -n -e '\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xff\xdb\x00C\x00\x08\x06\x06\x07\x06\x05\x08\x07\x07\x07\x09\x09\x08\x0a\x0c\x14\x0d\x0c\x0b\x0b\x0c\x19\x12\x13\x0f\x14\x1d\x1a\x1f\x1e\x1d\x1a\x1c\x1c $.\x27",#\x22\x1c\x1c(7telegramApi(telegramApi1444444444444444\xff\xc0\x00\x0b\x08\x00\x01\x00\x01\x01\x01\x11\x00\xff\xc4\x00\x1f\x00\x00\x01\x05\x01\x01\x01\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\xff\xc4\x00\xb5\x10\x00\x02\x01\x03\x03\x02\x04\x03\x05\x05\x04\x04\x00\x00\x01\x7d\x01\x02\x03\x00\x04\x11\x05\x12!1A\x06\x13Qa\x07"q\x142\x81\x91\xa1\x08#B\xb1\xc1\x15R\xd1\xf0$3br\x82\x09\x0a\x16\x17\x18\x19\x1a%&\x27()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz\x83\x84\x85\x86\x87\x88\x89\x8a\x92\x93\x94\x95\x96\x97\x98\x99\x9a\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xff\xda\x00\x08\x01\x01\x00\x00?\x00\xfb\xd5\x00\x00\x00\x00\x00\xff\xd9' > tests/e2e/fixtures/test-image.jpg || true

      - name: Run Newman E2E tests
        if: steps.check_e2e.outputs.exists == 'true' && env.skip_e2e != 'true'
        run: |
          newman run tests/e2e/postman/goimg-api.postman_collection.json \
            --environment tests/e2e/postman/ci.postman_environment.json \
            --reporters cli,htmlextra,junit \
            --reporter-htmlextra-export newman-report.html \
            --reporter-junit-export newman-report.xml \
            --bail || E2E_EXIT=$?

          # Exit with test result
          exit ${E2E_EXIT:-0}
        continue-on-error: true

      - name: Stop API server
        if: always() && env.API_PID != ''
        run: kill $API_PID || true

      - name: Add E2E Test Summary
        if: always() && steps.check_e2e.outputs.exists == 'true'
        run: |
          echo "## E2E Test Results (Newman)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ env.skip_e2e }}" == "true" ]; then
            echo "E2E tests skipped: API server not yet implemented" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "E2E tests will run automatically once the API server is implemented in Sprint 2." >> $GITHUB_STEP_SUMMARY
          elif [ -f "newman-report.xml" ]; then
            echo "E2E tests executed. See artifacts for detailed report." >> $GITHUB_STEP_SUMMARY
          else
            echo "No E2E test results found." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload Newman report
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4.4.0
        if: always() && steps.check_e2e.outputs.exists == 'true'
        with:
          name: newman-e2e-report
          path: |
            newman-report.html
            newman-report.xml
          retention-days: 30
          if-no-files-found: ignore

  # ============================================================================
  # Final Status Check - All critical jobs must pass
  # ============================================================================
  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    needs:
      - lint
      - test-unit
      - test-integration
      - domain-tests
      - coverage
      - openapi-validation
      - security-scan
      - build
      - e2e-tests
    if: always()

    steps:
      - name: Check all jobs status
        run: |
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            echo "One or more CI jobs failed"
            exit 1
          fi
          if [[ "${{ contains(needs.*.result, 'cancelled') }}" == "true" ]]; then
            echo "One or more CI jobs were cancelled"
            exit 1
          fi
          echo "All CI jobs passed successfully!"
